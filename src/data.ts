export interface Project {
  id: string; 
  name: string;
  desc: string;
  technologies: string[];

  fullDescription?: string; 
  process?: {
    title: string;
    description: string;
  }[];
  
  challenges?: string[];
  results?: string[];  
  links?: {
    github?: string;
    live?: string;
  };
}

export interface Experience {
  id: string;
  company: string;
  period: string;
  role: string;
  description: string;
  projects: Project[];
}

export const experiences: Experience[] = [
  {
    id: 'redlab',
    company: 'RedLab',
    period: 'Апрель 2024 - Текущее время',
    role: 'Middle Golang Developer',
    description: 'Разработка высоконагруженных систем...',
    projects: [
      {
        id: 'admin-backend',
        name: 'Internal Admin Panel',
        desc: 'Админка для управления пользователями и транзакциями.',
        technologies: ['Go', 'React', 'Rest API']
      }
    ]
  },
  {
    id: 'approfy',
    company: 'Approfy',
    period: 'Январь 2023 - Март 2024',
    role: 'Golang Developer',
    description: 'Работал в продуктовой команде над масштабируемыми Backend-решениями. Прошел путь от исправления технического долга в инфраструктуре до проектирования систем с большой пропускной способностью (10M+).',
    projects: [
      {
        id: 'subscription',
        name: 'Billing & Access Manager',
        desc: 'Система управления подписками и гибкого разграничения прав (RBAC).',
        technologies: ['Go', 'PostgreSQL', 'Redis', 'Stripe API', 'JWT'],
        fullDescription: 'Разработал модуль монетизации и контроля доступа. Система позволяет динамически изменять права пользователя при покупке подписки, блокировать доступ к премиум-функциям и управлять лимитами внутри приложения.',
        process: [
          {
            title: 'Проектирование RBAC-модели',
            description: 'Вместо жесткого хардкода ролей реализовал структуру: User -> Roles -> Permissions. Это позволило создавать новые тарифные планы без изменения кода.'
          },
          {
            title: 'Централизованный Middleware для Auth',
            description: 'Написал Middleware на Go, который на лету парсит JWT и проверяет права доступа (Scopes) перед тем, как запрос попадет в бизнес-логику. Это гарантирует 100% покрытие защищенных ручек.'
          },
          {
            title: 'Интеграция с платежным шлюзом',
            description: 'Реализовал обработку Webhooks от платежной системы. Использовал транзакции PostgreSQL, чтобы исключить ситуацию: деньги списаны, а роль не обновилась.'
          }
        ],
        challenges: [
          'Обработка состояния гонки (Race Condition) при одновременном продлении подписки с разных устройств.',
          'Безопасное хранение и инвалидация JWT-токенов при смене роли пользователя.',
          'Сложные запросы для проверки прав в иерархических структурах (например, когда права наследуются).'
        ],
        results: [
          'Система успешно выдерживает нагрузку в 5000+ запросов на проверку прав в секунду благодаря кэшированию в Redis.',
          'Полная автоматизация биллинга: ручное вмешательство техподдержки при оплатах снизилось до нуля.',
          'Реализована гибкая система Trial-периодов и промокодов, что увеличило конверсию в покупку на 15%.'
        ]
      },
      {
        id: 'data-unload',
        name: 'Data Unloader',
        desc: 'Система потокового экспорта данных на 10М+ записей.',
        technologies: ['Go', 'PostgreSQL', 'Docker'],
        fullDescription: 'Перед командой стояла задача обеспечить экспорт огромных массивов данных без падения производительности основной БД и перерасхода оперативной памяти.',
        process: [
          {
            title: 'Выбор стратегии чтения',
            description: 'Вместо обычной выгрузки через SELECT ALL был реализован курсорный подход (Keyset Pagination), что позволило читать данные фиксированными пачками.'
          },
          {
            title: 'Потоковая обработка (Streaming)',
            description: 'Использовал каналы в Go для передачи данных от парсера к энкодеру в реальном времени, что снизило потребление RAM до стабильных 50МБ.'
          }
        ],
        challenges: [
          'Ограничение памяти в Docker-контейнере (128MB).',
          'Медленные JOIN-ы на таблицах с миллионами записей.'
        ],
        results: [
          'Было достигнуто время генерации отчета за 2 минуты.',
          'Система успешно обрабатывает файлы размером до 5ГБ.'
        ]
      },
      {
        id: 'notifications',
        name: 'Notifications Service',
        desc: 'Система гарантированной доставки Push-уведомлений.',
        technologies: ['Go', 'PostgreSQL', 'Redis', 'RabbitMQ', 'FCM'],
        fullDescription: 'Существующая система рассылок работала синхронно и падала, при увеличении нагрузки. Задача была создать отказоустойчивый сервис, который принимает пачку уведомлений, буферизирует их и гарантированно доставляет пользователям, соблюдая лимиты провайдера.',
        process: [
          {
            title: 'Проектирование модели данных',
            description: 'Разработал схему БД, позволяющую одному пользователю иметь несколько активных устройств. Реализовал систему версионирования токенов для поддержки обновлений приложения.'
          },
          {
            title: 'Реализация идемпотентности API',
            description: 'Внедрил механизм дедупликации на основе Redis. API проверяет уникальные ID запросов, чтобы исключить повторную отправку пушей при сбоях на стороне вызывающего сервиса.'
          },
          {
            title: 'Асинхронная обработка',
            description: 'Разделил прием запросов и отправку. API валидирует запрос и кладет сообщение в RabbitMQ. Воркеры на Go вычитывают очередь и отправляют пуши параллельно.'
          },
          {
            title: 'Механизм Retry и DLQ',
            description: 'Реализовал стратегию Exponential Backoff: если внешний сервис (FCM) недоступен, сообщение возвращается в очередь с задержкой. "Битые" сообщения уходят в DLQ для ручного разбора.'
          },
          {
            title: 'Контроль нагрузки',
            description: 'Чтобы избежать блокировки со стороны Google/Apple, реализовал алгоритм Token Bucket в Redis. Воркеры автоматически снижают скорость отправки при приближении к лимитам провайдера.'
          }
        ],
        challenges: [
          'Обработка спайков нагрузки во время маркетинговых рассылок.',
          'Соблюдение Rate Limits внешних провайдеров (Google/Apple), для избежания блокировок.',
          'Проблема дубликатов сообщений при сетевых сбоях.'
        ],
        results: [
          'Пропускная способность выросла до 50 000 уведомлений в минуту.',
          'Zero-loss delivery: процент потерянных сообщений снизился с 5% до 0.01% (только невалидные токены).',
          'Время ответа API на прием рассылки сократилось до 10мс.'
        ]
      }
    ]
  }
];